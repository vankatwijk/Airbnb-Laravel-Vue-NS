"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var isNumber_1 = __importDefault(require("lodash/isNumber"));
var isString_1 = __importDefault(require("lodash/isString"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var isObject_1 = __importDefault(require("lodash/isObject"));
var isEmpty_1 = __importDefault(require("lodash/isEmpty"));
var isArray_1 = __importDefault(require("lodash/isArray"));
var sift_1 = __importDefault(require("sift"));
var query_1 = require("./errors/query");
var UNSUPPORTED_CONDITIONS = ['$nearSphere'];
var PROTECTED_FIELDS = ['_id', '_acl'];
function nested(obj, dotProperty, value) {
    if (!dotProperty) {
        return value || obj;
    }
    var parts = dotProperty.split('.');
    var currentProperty = parts.shift();
    var currentObj = obj;
    while (currentProperty && typeof currentObj !== 'undefined') {
        currentObj = currentObj[currentProperty];
        currentProperty = parts.shift();
    }
    return typeof currentObj === 'undefined' ? value : currentObj;
}
var Query = /** @class */ (function () {
    function Query(query) {
        var config = Object.assign({}, {
            fields: [],
            filter: {},
            sort: {},
            limit: Number.MAX_SAFE_INTEGER,
            skip: 0
        }, query);
        this.fields = config.fields;
        this.filter = config.filter;
        this.sort = config.sort;
        this.limit = config.limit;
        this.skip = config.skip;
    }
    Object.defineProperty(Query.prototype, "key", {
        get: function () {
            if ((this._skip && this._skip > 0) || (this._limit && this._limit < Number.MAX_SAFE_INTEGER)) {
                return null;
            }
            var queryObject = this.toQueryObject();
            return queryObject && !isEmpty_1.default(queryObject) ? JSON.stringify(queryObject) : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "fields", {
        get: function () {
            return this._fields;
        },
        set: function (fields) {
            if (!isArray_1.default(fields)) {
                throw new query_1.QueryError('fields must be an Array');
            }
            if (this._parent) {
                this._parent.fields = fields;
            }
            else {
                this._fields = fields;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "sort", {
        get: function () {
            return this._sort;
        },
        set: function (sort) {
            if (sort && !isPlainObject_1.default(sort)) {
                throw new query_1.QueryError('sort must an Object');
            }
            if (this._parent) {
                this._parent.sort = sort;
            }
            else {
                this._sort = sort;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "limit", {
        get: function () {
            return this._limit;
        },
        set: function (limit) {
            if (limit && !isNumber_1.default(limit)) {
                throw new query_1.QueryError('limit must be a number');
            }
            if (this._parent) {
                this._parent.limit = limit;
            }
            else {
                this._limit = limit;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Query.prototype, "skip", {
        get: function () {
            return this._skip;
        },
        set: function (skip) {
            if (!isNumber_1.default(skip)) {
                throw new query_1.QueryError('skip must be a number');
            }
            if (this._parent) {
                this._parent.skip = skip;
            }
            else {
                this._skip = skip;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true or false depending on if the query is able to be processed offline.
     *
     * @returns {boolean} True if the query is supported offline otherwise false.
     */
    Query.prototype.isSupportedOffline = function () {
        var _this = this;
        return Object.keys(this.filter).reduce(function (supported, key) {
            if (supported) {
                var value_1 = _this.filter[key];
                return UNSUPPORTED_CONDITIONS.some(function (unsupportedConditions) {
                    if (!value_1) {
                        return true;
                    }
                    if (!isObject_1.default(value_1)) {
                        return true;
                    }
                    return !Object.keys(value_1).some(function (condition) { return condition === unsupportedConditions; });
                });
            }
            return supported;
        }, true);
    };
    /**
     * Adds an equal to filter to the query. Requires field to equal value.
     * Any existing filters on field will be discarded.
     * @see https://docs.mongodb.com/manual/reference/operator/query/#comparison
     *
     * @param {string} field Field
     * @param {*} value Value
     * @returns {Query} Query
     */
    Query.prototype.equalTo = function (field, value) {
        return this.addFilter(field, value);
    };
    /**
     * Adds a not equal to filter to the query. Requires field not to equal
     * value.
     * @see https://docs.mongodb.com/manual/reference/operator/query/ne
     *
     * @param {string} field Field
     * @param {*} value Value
     * @returns {Query} Query
     */
    Query.prototype.notEqualTo = function (field, value) {
        return this.addFilter(field, '$ne', value);
    };
    /**
     * Adds a contains filter to the query. Requires field to contain at least
     * one of the members of list.
     * @see https://docs.mongodb.com/manual/reference/operator/query/in
     *
     * @param {string} field Field
     * @param {Array} values List of values.
     * @throws {Error} A value is required.
     * @returns {Query} Query
     */
    Query.prototype.contains = function (field, values) {
        if (!values) {
            throw new query_1.QueryError('You must supply a value.');
        }
        if (!Array.isArray(values)) {
            return this.addFilter(field, '$in', [values]);
        }
        return this.addFilter(field, '$in', values);
    };
    /**
     * Adds a not contained in filter to the query. Requires `field` not to
     * contain any of the members of `list`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/nin
     *
     * @param {string} field Field
     * @param {Array} values List of values.
     * @throws {Error} A value is required.
     * @returns {Query} Query
     */
    Query.prototype.notContainedIn = function (field, values) {
        if (!values) {
            throw new query_1.QueryError('You must supply a value.');
        }
        if (!Array.isArray(values)) {
            return this.addFilter(field, '$nin', [values]);
        }
        return this.addFilter(field, '$nin', values);
    };
    /**
     * Adds a contains all filter to the query. Requires `field` to contain all
     * members of `list`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/all
     *
     * @param {string} field Field
     * @param {object|Array} values List of values.
     * @throws {Error} A value is required.
     * @returns {Query} Query
     */
    Query.prototype.containsAll = function (field, values) {
        if (!values) {
            throw new query_1.QueryError('You must supply a value.');
        }
        if (!Array.isArray(values)) {
            return this.addFilter(field, '$all', [values]);
        }
        return this.addFilter(field, '$all', values);
    };
    /**
     * Adds a greater than filter to the query. Requires `field` to be greater
     * than `value`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/gt
     *
     * @param {string} field Field
     * @param {number|string} value Value
     * @throws {Error} The value must be a number or string.
     * @returns {Query} Query
     */
    Query.prototype.greaterThan = function (field, value) {
        if (!isNumber_1.default(value) && !isString_1.default(value)) {
            throw new query_1.QueryError('You must supply a number or string.');
        }
        return this.addFilter(field, '$gt', value);
    };
    /**
     * Adds a greater than or equal to filter to the query. Requires `field` to
     * be greater than or equal to `value`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/gte
     *
     * @param {string} field Field.
     * @param {number|string} value Value.
     * @throws {Error} The value must be a number or string.
     * @returns {Query} Query
     */
    Query.prototype.greaterThanOrEqualTo = function (field, value) {
        if (!isNumber_1.default(value) && !isString_1.default(value)) {
            throw new query_1.QueryError('You must supply a number or string.');
        }
        return this.addFilter(field, '$gte', value);
    };
    /**
     * Adds a less than filter to the query. Requires `field` to be less than
     * `value`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/lt
     *
     * @param {string} field Field
     * @param {number|string} value Value
     * @throws {Error} The value must be a number or string.
     * @returns {Query} Query
     */
    Query.prototype.lessThan = function (field, value) {
        if (!isNumber_1.default(value) && !isString_1.default(value)) {
            throw new query_1.QueryError('You must supply a number or string.');
        }
        return this.addFilter(field, '$lt', value);
    };
    /**
     * Adds a less than or equal to filter to the query. Requires `field` to be
     * less than or equal to `value`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/lte
     *
     * @param {string} field Field
     * @param {number|string} value Value
     * @throws {Error} The value must be a number or string.
     * @returns {Query} Query
     */
    Query.prototype.lessThanOrEqualTo = function (field, value) {
        if (!isNumber_1.default(value) && !isString_1.default(value)) {
            throw new query_1.QueryError('You must supply a number or string.');
        }
        return this.addFilter(field, '$lte', value);
    };
    /**
     * Adds an exists filter to the query. Requires `field` to exist if `flag` is
     * `true`, or not to exist if `flag` is `false`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/exists
     *
     * @param {string} field Field
     * @param {boolean} [flag=true] The exists flag.
     * @returns {Query} Query
     */
    Query.prototype.exists = function (field, flag) {
        if (flag === void 0) { flag = true; }
        return this.addFilter(field, '$exists', flag === true);
    };
    /**
     * Adds a modulus filter to the query. Requires `field` modulo `divisor` to
     * have remainder `remainder`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/mod
     *
     * @param {string} field Field
     * @param {number} divisor Divisor
     * @param {number} [remainder=0] Remainder
     * @throws {Error} The divisor must be a number.
     * @throws {Error} The remainder must be a number.
     * @returns {Query} Query
     */
    Query.prototype.mod = function (field, divisor, remainder) {
        if (remainder === void 0) { remainder = 0; }
        if (!isNumber_1.default(divisor)) {
            throw new query_1.QueryError('divisor must be a number');
        }
        if (!isNumber_1.default(remainder)) {
            throw new query_1.QueryError('remainder must be a number');
        }
        return this.addFilter(field, '$mod', [divisor, remainder]);
    };
    /**
     * Adds a match filter to the query. Requires `field` to match `regExp`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/regex
     *
     * @param {string} field Field
     * @param {RegExp|string} regExp Regular expression.
     * @param {Object} [options] Options
     * @param {boolean} [options.ignoreCase=inherit] Toggles case-insensitivity.
     * @param {boolean} [options.multiline=inherit] Toggles multiline matching.
     * @param {boolean} [options.extended=false] Toggles extended capability.
     * @param {boolean} [options.dotMatchesAll=false] Toggles dot matches all.
     * @throws {Error} The regExp must have '^' at the beginning of the expression to make it an anchored expression.
     * @throws {Error} The ignoreCase flag is not supported.
     * @returns {Query} Query
     */
    Query.prototype.matches = function (field, expression, options) {
        if (options === void 0) { options = {}; }
        var flags = [];
        var regExp = expression;
        if (!(regExp instanceof RegExp)) {
            regExp = new RegExp(regExp);
        }
        if (regExp.source.indexOf('^') !== 0) {
            throw new query_1.QueryError('regExp must have \'^\' at the beginning of the expression to make it an anchored expression.');
        }
        if ((regExp.ignoreCase || options.ignoreCase) && options.ignoreCase !== false) {
            throw new query_1.QueryError('ignoreCase flag is not supported');
        }
        if ((regExp.multiline || options.multiline) && options.multiline !== false) {
            flags.push('m');
        }
        if (options.extended === true) {
            flags.push('x');
        }
        if (options.dotMatchesAll === true) {
            flags.push('s');
        }
        if (flags.length > 0) {
            this.addFilter(field, '$options', flags.join(''));
        }
        return this.addFilter(field, '$regex', regExp.source);
    };
    /**
     * Adds a near filter to the query. Requires `field` to be a coordinate
     * within `maxDistance` of `coord`. Sorts documents from nearest to farthest.
     * @see https://docs.mongodb.com/manual/reference/operator/query/near
     *
     * @param {string} field The field.
     * @param {Array<number, number>} coord The coordinate (longitude, latitude).
     * @param {number} [maxDistance] The maximum distance (miles).
     * @throws {Error} The coord must be a [number, number].
     * @returns {Query} Query
     */
    Query.prototype.near = function (field, coord, maxDistance) {
        if (!Array.isArray(coord) || !isNumber_1.default(coord[0]) || !isNumber_1.default(coord[1])) {
            throw new query_1.QueryError('coord must be a [number, number]');
        }
        var result = this.addFilter(field, '$nearSphere', [coord[0], coord[1]]);
        if (isNumber_1.default(maxDistance)) {
            this.addFilter(field, '$maxDistance', maxDistance);
        }
        return result;
    };
    /**
     * Adds a within box filter to the query. Requires `field` to be a coordinate
     * within the bounds of the rectangle defined by `bottomLeftCoord`,
     * `bottomRightCoord`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/box
     *
     * @param {string} field The field.
     * @param {Array<number, number>} bottomLeftCoord The bottom left coordinate (longitude, latitude).
     * @param {Array<number, number>} upperRightCoord The bottom right coordinate (longitude, latitude).
     * @throws {Error} The bottomLeftCoord must be a [number, number].
     * @throws {Error} The upperRightCoord must be a [number, number].
     * @returns {Query} Query
     */
    Query.prototype.withinBox = function (field, bottomLeftCoord, upperRightCoord) {
        if (!Array.isArray(bottomLeftCoord)
            || !isNumber_1.default(bottomLeftCoord[0])
            || !isNumber_1.default(bottomLeftCoord[1])) {
            throw new query_1.QueryError('bottomLeftCoord must be a [number, number]');
        }
        if (!Array.isArray(upperRightCoord)
            || !isNumber_1.default(upperRightCoord[0])
            || !isNumber_1.default(upperRightCoord[1])) {
            throw new query_1.QueryError('upperRightCoord must be a [number, number]');
        }
        var coords = [
            [bottomLeftCoord[0], bottomLeftCoord[1]],
            [upperRightCoord[0], upperRightCoord[1]]
        ];
        return this.addFilter(field, '$within', { $box: coords });
    };
    /**
     * Adds a within polygon filter to the query. Requires `field` to be a
     * coordinate within the bounds of the polygon defined by `coords`.
     * @see https://docs.mongodb.com/manual/reference/operator/query/polygon
     *
     * @param {string} field The field.
     * @param {Array<Array<number, number>>} coords List of coordinates.
     * @throws {Error} The coords must be a [[number, number]].
     * @returns {Query} Query
     */
    Query.prototype.withinPolygon = function (field, coords) {
        if (Array.isArray(coords) === false || coords.length === 0 || coords[0].length > 3) {
            throw new query_1.QueryError('coords must be a [[number, number]]');
        }
        var withinCoords = coords.map(function (coord) {
            if (!isNumber_1.default(coord[0]) || !isNumber_1.default(coord[1])) {
                throw new query_1.QueryError('coords argument must be a [number, number]');
            }
            return [coord[0], coord[1]];
        });
        return this.addFilter(field, '$within', { $polygon: withinCoords });
    };
    /**
     * Adds a size filter to the query. Requires `field` to be an `Array` with
     * exactly `size` members.
     * @see https://docs.mongodb.com/manual/reference/operator/query/size
     *
     * @param {string} field Field
     * @param {number} size Size
     * @throws {Error} The size must be a number.
     * @returns {Query} Query
     */
    Query.prototype.size = function (field, size) {
        if (!isNumber_1.default(size)) {
            throw new query_1.QueryError('size must be a number');
        }
        return this.addFilter(field, '$size', size);
    };
    /**
     * Adds an ascending sort modifier to the query. Sorts by `field`, ascending.
     *
     * @param {string} field Field
     * @returns {Query} Query
     */
    Query.prototype.ascending = function (field) {
        if (!isString_1.default(field)) {
            throw new query_1.QueryError('The provided field must be a string.');
        }
        if (this._parent) {
            this._parent.ascending(field);
        }
        else {
            if (!this.sort) {
                this.sort = {};
            }
            this.sort[field] = 1;
        }
        return this;
    };
    /**
     * Adds an descending sort modifier to the query. Sorts by `field`,
     * descending.
     *
     * @param {string} field Field
     * @returns {Query} Query
     */
    Query.prototype.descending = function (field) {
        if (!isString_1.default(field)) {
            throw new query_1.QueryError('The provided field must be a string.');
        }
        if (this._parent) {
            this._parent.descending(field);
        }
        else {
            if (!this.sort) {
                this.sort = {};
            }
            this.sort[field] = -1;
        }
        return this;
    };
    /**
     * Performs a logical AND operation on the query and the provided queries.
     * @see https://docs.mongodb.com/manual/reference/operator/query/and
     *
     * @param {...Query|...Object} args Queries
     * @throws {Error} Queries must be an array of Query instances or objects.
     * @returns {Query} Query
     */
    Query.prototype.and = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // AND has highest precedence. Therefore, even if this query is part of a
        // JOIN already, apply it on this query.
        return this.join('$and', args);
    };
    /**
     * Performs a logical NOR operation on the query and the provided queries.
     * @see https://docs.mongodb.com/manual/reference/operator/query/nor
     *
     * @param {...Query|...Object} args Queries
     * @throws {Error} Queries must be an array of Query instances or objects.
     * @returns {Query} Query
     */
    Query.prototype.nor = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // NOR is preceded by AND. Therefore, if this query is part of an AND-join,
        // apply the NOR onto the parent to make sure AND indeed precedes NOR.
        if (this._parent && Object.hasOwnProperty.call(this._parent.filter, '$and')) {
            return (_a = this._parent.nor).apply.apply(_a, [this._parent].concat(args));
        }
        return this.join('$nor', args);
    };
    /**
     * Performs a logical OR operation on the query and the provided queries.
     * @see https://docs.mongodb.com/manual/reference/operator/query/or
     *
     * @param {...Query|...Object} args Queries.
     * @throws {Error} Queries must be an array of Query instances or objects.
     * @returns {Query} Query
     */
    Query.prototype.or = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // OR has lowest precedence. Therefore, if this query is part of any join,
        // apply the OR onto the parent to make sure OR has indeed the lowest
        // precedence.
        if (this._parent) {
            return (_a = this._parent.or).apply.apply(_a, [this._parent].concat(args));
        }
        return this.join('$or', args);
    };
    /**
     * Returns query string representation of the query as a JavaScript object.
     *
     * @returns {Object} Query string object.
     */
    Query.prototype.toQueryObject = function () {
        var queryPlainObject = this.toPlainObject();
        var queryObject = {};
        if (Object.keys(queryPlainObject.filter).length > 0) {
            queryObject.query = queryPlainObject.filter;
        }
        if (queryPlainObject.fields && queryPlainObject.fields.length > 0) {
            queryObject.fields = queryPlainObject.fields.join(',');
        }
        if (isNumber_1.default(queryPlainObject.limit) && queryPlainObject.limit < Number.MAX_SAFE_INTEGER) {
            queryObject.limit = queryPlainObject.limit;
        }
        if (isNumber_1.default(queryPlainObject.skip) && queryPlainObject.skip > 0) {
            queryObject.skip = queryPlainObject.skip;
        }
        if (queryPlainObject.sort && Object.keys(queryPlainObject.sort).length > 0) {
            queryObject.sort = queryPlainObject.sort;
        }
        Object.keys(queryObject).forEach(function (key) {
            queryObject[key] = isString_1.default(queryObject[key]) ? queryObject[key] : JSON.stringify(queryObject[key]);
        });
        return queryObject;
    };
    /**
     * @deprecated
     * Please use Query.prototype.toQueryObject() instead.
     */
    Query.prototype.toQueryString = function () {
        return this.toQueryObject();
    };
    /**
     * Returns Object representation of the query.
     *
     * @returns {Object} Object
     */
    Query.prototype.toPlainObject = function () {
        if (this._parent) {
            return this._parent.toPlainObject();
        }
        // Return set of parameters.
        var json = {
            fields: this.fields,
            filter: this.filter,
            sort: this.sort,
            skip: this.skip,
            limit: this.limit
        };
        return json;
    };
    /**
     * Returns query string representation of the query.
     *
     * @return {string} Query string string.
     */
    Query.prototype.toString = function () {
        return JSON.stringify(this.toQueryString());
    };
    /**
     * @private
     * Adds a filter to the query.
     *
     * @param {string} field Field
     * @param {string} condition Condition
     * @param {*} values Values
     * @returns {Query} Query
     */
    Query.prototype.addFilter = function (field) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!isString_1.default(field)) {
            throw new query_1.QueryError('The field argument must be a string.');
        }
        var _a = args.length === 2
            ? { condition: args[0], values: args[1] }
            : { condition: undefined, values: args[0] }, condition = _a.condition, values = _a.values;
        if (!this.filter) {
            this.filter = {};
        }
        if (condition) {
            if (!this.filter[field]) {
                this.filter[field] = {};
            }
            this.filter[field][condition] = values;
        }
        else {
            this.filter[field] = values;
        }
        return this;
    };
    /**
     * @private
     * Joins the current query with another query using an operator.
     *
     * @param {string} operator Operator
     * @param {Query[]|object[]} queries Queries
     * @throws {Error} Queries must be an array of Query instances or objects.
     * @returns {Query} Query
     */
    Query.prototype.join = function (operator, queries) {
        var _this = this;
        // Cast, validate, and parse arguments. If `queries` are supplied, obtain
        // the `filter` for joining. The eventual return function will be the
        // current query.
        var result = new Query(this);
        var filters = queries.map(function (queryObject) {
            var query = queryObject;
            if (!(queryObject instanceof Query)) {
                if (isPlainObject_1.default(queryObject)) {
                    query = new Query(queryObject);
                }
                else {
                    throw new query_1.QueryError('query argument must be of type: Kinvey.Query[] or Object[].');
                }
            }
            return query.toPlainObject().filter;
        });
        // If there are no `queries` supplied, create a new (empty) `Kinvey.Query`.
        // This query is the right-hand side of the join expression, and will be
        // returned to allow for a fluent interface.
        if (filters.length === 0) {
            result = new Query();
            filters = [result.toPlainObject().filter];
            result._parent = new Query(this);
        }
        // Join operators operate on the top-level of `_filter`. Since the `toJSON`
        // magic requires `_filter` to be passed by reference, we cannot simply re-
        // assign `_filter`. Instead, empty it without losing the reference.
        var currentFilter = Object.keys(this.filter).reduce(function (filter, key) {
            filter[key] = _this.filter[key];
            delete _this.filter[key];
            return filter;
        }, {});
        // `currentFilter` is the left-hand side query. Join with `filters`.
        this.addFilter(operator, [currentFilter].concat(filters));
        return result;
    };
    Query.prototype.process = function (docs) {
        if (docs === void 0) { docs = []; }
        var queryPlainObject = this.toPlainObject();
        if (!Array.isArray(docs)) {
            throw new Error('data argument must be of type: Array.');
        }
        if (!this.isSupportedOffline()) {
            throw new Error('This query is not able to run locally.');
        }
        if (docs.length > 0) {
            var processedDocs = void 0;
            var filter = queryPlainObject.filter;
            if (filter && !isEmpty_1.default(filter)) {
                processedDocs = sift_1.default(filter, docs);
            }
            else {
                processedDocs = docs;
            }
            if (!isEmpty_1.default(queryPlainObject.sort)) {
                // eslint-disable-next-line arrow-body-style
                processedDocs.sort(function (a, b) {
                    return Object.keys(queryPlainObject.sort)
                        .reduce(function (result, field) {
                        if (typeof result !== 'undefined' && result !== 0) {
                            return result;
                        }
                        if (Object.prototype.hasOwnProperty.call(queryPlainObject.sort, field)) {
                            var aField = nested(a, field);
                            var bField = nested(b, field);
                            var modifier = queryPlainObject.sort[field]; // -1 (descending) or 1 (ascending)
                            if ((aField !== null && typeof aField !== 'undefined')
                                && (bField === null || typeof bField === 'undefined')) {
                                return 1 * modifier;
                            }
                            else if ((bField !== null && typeof bField !== 'undefined')
                                && (aField === null || typeof aField === 'undefined')) {
                                return -1 * modifier;
                            }
                            else if (typeof aField === 'undefined' && bField === null) {
                                return 0;
                            }
                            else if (aField === null && typeof bField === 'undefined') {
                                return 0;
                            }
                            else if (aField !== bField) {
                                return (aField < bField ? -1 : 1) * modifier;
                            }
                        }
                        return 0;
                    }, undefined);
                });
            }
            if (isNumber_1.default(queryPlainObject.skip) && queryPlainObject.skip > 0) {
                if (isNumber_1.default(queryPlainObject.limit) && queryPlainObject.limit < Number.MAX_SAFE_INTEGER) {
                    processedDocs = processedDocs.slice(queryPlainObject.skip, queryPlainObject.skip + queryPlainObject.limit);
                }
                else {
                    processedDocs = processedDocs.slice(queryPlainObject.skip);
                }
            }
            else if (isNumber_1.default(queryPlainObject.limit) && queryPlainObject.limit < Number.MAX_SAFE_INTEGER) {
                processedDocs = processedDocs.slice(0, queryPlainObject.limit);
            }
            if (isArray_1.default(queryPlainObject.fields) && queryPlainObject.fields.length > 0) {
                processedDocs = processedDocs.map(function (doc) {
                    var modifiedDoc = doc;
                    Object.keys(modifiedDoc).forEach(function (key) {
                        if (queryPlainObject.fields && queryPlainObject.fields.indexOf(key) === -1 && PROTECTED_FIELDS.indexOf(key) === -1) {
                            delete modifiedDoc[key];
                        }
                    });
                    return modifiedDoc;
                });
            }
            return processedDocs;
        }
        return docs;
    };
    return Query;
}());
exports.Query = Query;
//# sourceMappingURL=query.js.map